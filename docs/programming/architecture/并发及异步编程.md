
Table of Contents
=================

   * [并发及异步编程](#并发及异步编程)
      * [参考引用](#参考引用)
      * [定义](#定义)
      * [问题背景](#问题背景)
      * [基本概念](#基本概念)
         * [进程、线程与协程](#进程线程与协程)
         * [并发与并行](#并发与并行)
         * [同步和异步，阻塞和非阻塞](#同步和异步阻塞和非阻塞)
         * [锁](#锁)
      * [Python下的异步编程](#python下的异步编程)
         * [GIL锁](#gil锁)
      * [编程实例](#编程实例)
         * [问题](#问题)
         * [设计思路](#设计思路)
         * [与顺序重试的测试对比](#与顺序重试的测试对比)

Created by ALTA
# 并发及异步编程  
<font color=#008000>绿色字体</font>代表个人的思考理解，<font color=Yellow>黄色字体</font>代表阅读理解过程中的疑问，<font color=Red>红色字体</font>代表关键重要信息，<u>下划线</u>代表次关键重要信息，`阴影`或 *一般斜体* 均表示引用或强调 

```python
# ---------------------------------- 输出结果
```

 ## 参考引用  

本文引用及参考自下列文章/网站：  

1. [线程，进程，协程详细解释](<https://blog.csdn.net/WJWFighting/article/details/82589177>)  
2. [一文读懂什么是进程、线程、协程](https://www.cnblogs.com/Survivalist/p/11527949.html)  
3. [深入理解 Python 异步编程(上)](<https://www.jianshu.com/p/794c7887b0cb>)

## 定义  

进程：进程是资源分配的最小单位。进程是“程序执行的一个实例” ，担当分配系统资源的实体。进程创建必须分配一个完整的独立地址空间。  

线程：线程是程序执行的最小单位，（英语：thread）是操作系统能够进行运算调度的最小单位  

协程：协程是轻量级的线程，`子程序其实是协程的特例`

## 问题背景  

线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。 在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程(Lightweight Process，LWP），后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有一个或多个线程。同样地，当人们发现线程间上下文的切换效率还是不能满足要求，于是发明任务粒度更细、资源共享/权限更大的协程(<font color=limegreen>说白了就是随着情况变得复杂，需要划分更细的任务粒度，扩大资源共享的范围或者权限以提升效率。当进程过渡到线程时，任务粒度变细，然后资源共享的范围扩大(线程间可共享内存空间、堆等，进程则不可)，但进程和线程仍由OS进行调度(确认一下是否是时间片轮转抢占调度方式)，当线程过渡到协程时，任务粒度变得更细，同时为了减少调度开销，调度权限下放给用户</font>)。

因为子程序切换不是线程切换，而是由程序自身控制(<font color=red>进程、线程的调度都是由OS控制，参考引用1</font>)，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显  

<font color=limegreen>总而言之，创造进程/线程/协程、并发/并行/同步/异步/阻塞/非阻塞/回调/锁等概念都是为了达到一个目的(解决一个问题)：资源满载，避免空闲，提升效率。能同时干的事情同时干(并发、并行等方式)，不能同时干(需要等待)的事情想办法(异步、回调等方式)同时干。进程/线程/协程等是数据结构、是操作的对象，并发/并行/同步/异步/阻塞/非阻塞/回调/锁等是算法、是操作的方法或机制，两者都是服务于一个目的：同时干</font>  

## 基本概念  

### 进程、线程与协程  

进程：任一时刻，一台处理器(CPU)总是运行一个 **进程**，其他 **进程** 处于非运行状态(UNIX表面的多进程是分时复用)

线程：一个 **进程** 可以包括多个 **线程**，  **进程** 的内存空间是共享的，每个 **线程** 都可以使用这些共享内存，多个线程协同完成一个任务

协程：Python对协程的支持是通过generator实现的.

`子程序就是协程的一种特例 ——Donald Knuth`

### 并发与并行  

并行是在一台处理器上“同时”处理多个任务(多线程)，并发是在多台处理器上同时处理多个任务(多进程)  

### 同步和异步，阻塞和非阻塞  

同步： 被调用者"不主动”返回，即没有回调过程

异步： 被调用者主动返回，即有回调过程，被调用者执行成功之后会"主动"返回给调用者结果

阻塞： 调用者在等待被调用者的返回，直到返回了才继续

非阻塞： 调用者不等待被调用者的返回，装完逼(发起了调用)就跑  

### 锁  

互斥锁(mutex): 某资源在一时间只允许一个进程/线程使用  

信号量(semaphore)：某资源在一时间允许若干个(n)进程/线程使用，上n把锁，当进程/线程大于n的时候，后来的进程/线程就需要等前面n个进程/线程中的某个进程/线程释放锁。mutex是semaphore的特例(n=1)  

## Python下的异步编程  

### GIL锁  

GIL 是CPython 解释器（平常称为 Python）中的一个技术术语，中文译为全局解释器锁，其本质上类似操作系统的 Mutex。GIL 的功能是：在 CPython 解释器中执行的每一个 Python 线程，解释器都会先锁住自己仅供当前线程执行，以阻止别的线程执行。当然，CPython 不可能容忍一个线程一直独占解释器，它会轮流执行 Python 线程。这样一来，用户看到的就是“伪”并行，即 Python 线程在交替执行，来模拟真正并行的线程。既然 CPython 能控制线程伪并行，为什么还需要 GIL 呢？其实，这和 CPython 的底层内存管理有关。

```python
>>> import sys
>>> a = []
>>> b = a
>>> sys.getrefcount(a)
3
```

可以看到，a 的引用计数值为 3，因为有 a、b 和作为参数传递的 getrefcount 都引用了一个空列表。假设有两个 Python 线程同时引用 a，那么双方就都会尝试操作该数据，很有可能造成引用计数的条件竞争，导致引用计数只增加 1（实际应增加 2(<font color=Yellow>有点困惑，既然CPython可以轮流执行线程，那么前面说的'同时引用a'是什么意思？既然是轮流执行线程，甲线程引用的时候计数加一，轮到乙线程的时候再加一，这样计数不就加2了吗？</font>)），这造成的后果是，当第一个线程结束时，会把引用计数减少 1，此时可能已经达到释放内存的条件（引用计数为 0），当第 2 个线程再次视图访问 a 时，就无法找到有效的内存了  



## 编程实例  

### 问题  

client请求server，请求时server可能处于流量峰值，从而中断了client的请求，流量的峰值随机出现，假设client对于请求有时间限制t，在该时间内client必须拿到请求结果，无论是成功还是失败的结果，那么问题来了：如何提高成功的概率？  

### 设计思路  

提高成功概率的根本在于重试，直至成功。但是因为有时间限制t，所以如果顺序执行(失败后重试，重试失败后再重试，直至时间截止)，重试的次数会比较少，成功概率低。所以我们的方法就变成了：**同时干**，时间限制内同时建立多个连接发起多个请求，只要有一个连接成功了都意味着任务成功，哪怕其中有连接被server中断。  

分析具体需求：

1. 同时建立多个连接发起多个请求，可以选择多进程、多线程、多协程  
2. 发起请求后，主进程/线程/协程不需要等待请求的返回，所以采取非阻塞的方式  
3. 请求的返回应该主动告诉调用者(主进程/线程/协程)，所以采取异步的方式  

基于效率的考虑，优先采用多协程，这就意味着需要自己编写调度管理(即事件循环)

### 与顺序重试的测试对比  

left blank  



