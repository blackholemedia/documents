
Table of Contents
=================

   * [并发及异步编程](#并发及异步编程)
      * [阅读说明](#阅读说明)
      * [参考引用](#参考引用)
      * [定义](#定义)
      * [问题背景](#问题背景)
      * [基本概念](#基本概念)
         * [进程、线程与协程](#进程线程与协程)
         * [并发与并行](#并发与并行)
         * [同步和异步，阻塞和非阻塞](#同步和异步阻塞和非阻塞)
         * [锁](#锁)
         * [竞态条件](#竞态条件)
      * [基本概念的进一步解释](#基本概念的进一步解释)
         * [并发与并行](#并发与并行-1)
         * [进程](#进程)
         * [协程](#协程)
         * [线程、协程的具体资源共享范围](#线程协程的具体资源共享范围)
         * [协程(coroutine)与生成器(generator)的区别](#协程coroutine与生成器generator的区别)
      * [异步编程](#异步编程)
         * [同步阻塞](#同步阻塞)
         * [以多进程方式改进](#以多进程方式改进)
         * [以多线程方式改进](#以多线程方式改进)
         * [以异步非阻塞方式改进](#以异步非阻塞方式改进)
         * [以协程（yield）模式的异步非阻塞方式改进](#以协程yield模式的异步非阻塞方式改进)
         * [GIL锁](#gil锁)
         * [基本异步编程](#基本异步编程)
         * [在基本异步编程上的改进](#在基本异步编程上的改进)
      * [编程实例设计](#编程实例设计)
         * [问题](#问题)
         * [设计思路](#设计思路)
         * [与顺序重试的测试对比](#与顺序重试的测试对比)

Created by ALTA
# 并发及异步编程  
## 阅读说明  

<font color=#008000>绿色字体</font>代表个人的思考理解，<font color=Yellow>黄色字体</font>代表阅读理解过程中的疑问，<font color=Red>红色字体</font>代表关键重要信息，<u>下划线</u>代表次关键重要信息，`阴影`或 *一般斜体* 均表示引用或强调    

```python
# ---------------------------------- 输出结果
```

 ## 参考引用  

本文引用及参考自下列文章/网站：  

1. [线程，进程，协程详细解释](<https://blog.csdn.net/WJWFighting/article/details/82589177>)  
2. [一文读懂什么是进程、线程、协程](https://www.cnblogs.com/Survivalist/p/11527949.html)  
3. [深入理解 Python 异步编程(上)](https://mp.weixin.qq.com/s/H-0pd3NcAJDbUckNi0-IEw)  
4. [编程思想之多线程与多进程(1)——以操作系统的角度述说线程与进程](https://blog.csdn.net/luoweifu/article/details/46595285)  
5. [java如何实现多个线程并发运行](https://www.cnblogs.com/svennee/p/4081155.html)  
6. [同一进程的线程共享的资源和独有的资源](https://zhuanlan.zhihu.com/p/337697030)  
7. [Python中协程(coroutine)和生成器(generator)的区别](https://www.jianshu.com/p/5103c6a63e33)

## 定义  

进程：进程是资源分配的最小单位。进程是“程序执行的一个实例” ，担当分配系统资源的实体。进程创建必须分配一个完整的独立地址空间。  

线程：线程是程序执行的最小单位，（英语：thread）是操作系统能够进行运算调度的最小单位  

协程：协程是轻量级的线程，`子程序其实是协程的特例`

## 问题背景  

线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。 在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程(Lightweight Process，LWP），后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有一个或多个线程。同样地，当人们发现线程间上下文的切换效率还是不能满足要求，于是发明任务粒度更细、资源共享/权限更大的协程(<font color=limegreen>说白了就是随着情况变得复杂，需要划分更细的任务粒度，扩大资源共享的范围或者权限以提升效率。当进程过渡到线程时，任务粒度变细，然后资源共享的范围扩大(线程间可共享内存空间、堆等，进程则不可)，但进程和线程仍由OS进行调度(确认一下是否是时间片轮转抢占调度方式)，当线程过渡到协程时，任务粒度变得更细，同时为了减少调度开销，调度权限下放给用户</font>)。

因为子程序切换不是线程切换，而是由程序自身控制(<font color=red>进程、线程的调度都是由OS控制，参考引用1</font>)，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显  

<font color=limegreen>总而言之，创造进程/线程/协程、并发/并行/同步/异步/阻塞/非阻塞/回调/锁等概念都是为了达到一个目的(解决一个问题)：资源满载，避免空闲，提升效率。能同时干的事情同时干(并发、并行等方式)，不能同时干(需要等待)的事情想办法(异步、回调等方式)同时干。进程/线程/协程等是数据结构、是操作的对象，并发/并行/同步/异步/阻塞/非阻塞/回调/锁等是算法、是操作的方法或机制，两者都是服务于一个目的：同时干</font>  

## 基本概念  

### 进程、线程与协程  

进程：任一时刻，一台处理器(CPU)总是运行一个 **进程**，其他 **进程** 处于非运行状态(UNIX表面的多进程是分时复用)

线程：一个 **进程** 可以包括多个 **线程**，  **进程** 的内存空间是共享的，每个 **线程** 都可以使用这些共享内存，多个线程协同完成一个任务

协程：Python对协程的支持是通过generator实现的.

`子程序就是协程的一种特例 ——Donald Knuth`

### 并发与并行  

并行是在一台处理器上“同时”处理多个任务(多线程)，并发是在多台处理器上同时处理多个任务(多进程)  

### 同步和异步，阻塞和非阻塞  

同步： 被调用者"不主动”返回，即没有回调过程

异步： 被调用者主动返回，即有回调过程，被调用者执行成功之后会"主动"返回给调用者结果

阻塞： 调用者在等待被调用者的返回，直到返回了才继续

非阻塞： 调用者不等待被调用者的返回，装完逼(发起了调用)就跑  

### 锁  

互斥锁(mutex): 某资源在一时间只允许一个进程/线程使用  

信号量(semaphore)：某资源在一时间允许若干个(n)进程/线程使用，上n把锁，当进程/线程大于n的时候，后来的进程/线程就需要等前面n个进程/线程中的某个进程/线程释放锁。mutex是semaphore的特例(n=1)  

### 竞态条件  

竞态条件是指同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件，代码区成为临界区。最常见的竞态条件为：先检测后执行。执行依赖于检测的结果，而检测结果依赖于多个线程的执行时序，而多个线程的执行时序通常情况下是不固定不可判断的，从而导致执行结果出现各种问题  

## 基本概念的进一步解释  

### 并发与并行  

在单CPU系统中，系统调度在某一时刻只能让一个线程运行，虽然这种调试机制有多种形式(大多数是时间片轮转抢占式调度	为主)，但无论如何，要通过不断切换需要运行的线程让其运行的方式就叫并发(concurrent)。而在多CPU系统中，可以让两个以上的线程同时运行，这种可以同时让两个以上线程同时运行的方式叫做并行(parallel)。  

<font color=limegreen>根据上述表述有如下推论：</font>  

1. <font color=limegreen>并发/并行的描述对象是线程，任何进程都可以同其他进程一起并发执行，并发性是进程的基本特征(参考下文)，所以讨论并发/并行时一般指代线程的并发/并行而非进程</font>
2. <font color=limegreen>这也解释了GIL锁为什么造成python伪并行的情况，因为GIL锁是全局排它锁，同一个时刻只允许一个线程可以使用CPU(无论是单核CPU还是多CPU的某个核)，不允许多个线程在多个CPU上同时运行，所以Python多线程其实并不是「并行」的，而是「并发」</font>

### 进程  

进程一般由程序、数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。  

进程具有的特征：

动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；

并发性：任何进程都可以同其他进程一起并发执行；

独立性：进程是系统进行资源分配和调度的一个独立单位；

结构性：进程由程序、数据和进程控制块三部分组成  

### 协程  

**协程(Co-routine)，即是协作式的例程**，它是非抢占式的多任务子例程的概括，可以<u>允许有多个入口点在例程中确定的位置来控制程序的暂停与恢复执行</u>。例程是什么？编程语言定义的可被调用的代码段，为了完成某个特定功能而封装在一起的一系列指令。一般的编程语言都用称为函数或方法的代码结构来体现。

### 线程、协程的具体资源共享范围  

线程的共享资源范围：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID

线程的私有资源范围：

1. 线程ID。 每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程；  
2. 寄存器组的值。由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复;  
3. 线程的堆栈。堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响；  
4. 错误返回码。由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量；  
5. 线程的信号屏蔽码。由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器； 
6. 线程的优先级。由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级

### 协程(coroutine)与生成器(generator)的区别  

协程和生成器都使用yield关键字。但是协程更像是对生成器语法的一些扩展(<font color=limegreen>根据上文协程定义，生成器可用于实现协程，换言之协程也可用其他方式实现，python下可能只有生成器</font>)  

- 在生成器中, yield 只对外产出值  
- 在协程中，yield能对外产出值，而且能接收通过send()方法传入值

## 异步编程  

### 同步阻塞    

可以单纯地理解为循环执行，循环体即为任务逻辑代码(平均耗时为T)，任务逻辑代码包含I/O并且以阻塞等待方式读取I/O， 循环次数为N，总时间为 T × N  

缺点： 效率低下

### 以多进程方式改进  

并发性是进程的基本特征(参考上文)，所以并发执行任务逻辑代码，该并发由OS调度，总时间略多于T  

优点：独立性是进程的基本特征(参考上文)，多个进程间数据不会相互干扰(不存在竞态条件)

缺点：1.略多于T而不是等于T是因为存在进程切换开销，这种开销对于CPU角度而言是巨大的；2.OS支持的并发规模有限；3.独立性(既是优点也是缺点)，由于进程间数据不会相互干扰导致进程间共享状态困难

### 以多线程方式改进  

与多进程方式一致，现代操作系统基本以线程取代进程作为任务执行方式(不然为啥线程叫LWP)，并发由OS调度，总时间约为T  

优点：1.克服了多进程的缺点1，切换开销小；2.克服了多进程缺点2，并发规模高  

缺点：1.为了克服切换开销大而扩大了资源共享范围，从而引入了竞态条件，这是核心缺陷(<font color=Yellow>此处举个例子，可以用GIL锁的例子说明</font>)；2.任务的并发规模仍然不够高

<font color=red>由上述多进程、多线程的优缺点可知，并发编程的核心问题在于控制子任务的资源共享范围，达到合理的平衡。既希望资源共享范围大，使得子任务间切换的开销小、子任务间通信方便，又希望资源共享范围小，使得子任务间数据独立不相互干扰/污染</font>  

### 以异步非阻塞方式改进  

```python
selector = DefaultSelector()
stopped = False
urls_todo = {'/', '/1', '/2', '/3', '/4', '/5', '/6', '/7', '/8', '/9'}

class Crawler:
    def __init__(self, url):
        self.url = url
        self.sock = None
        self.response = b''

    def fetch(self):
        self.sock = socket.socket()
        self.sock.setblocking(False)
        try:
            self.sock.connect(('example.com', 80))
        except BlockingIOError:
            pass
        selector.register(self.sock.fileno(), EVENT_WRITE, self.connected)

    def connected(self, key, mask):
        selector.unregister(key.fd)
        get = 'GET {0} HTTP/1.0\r\nHost: example.com\r\n\r\n'.format(self.url)
        self.sock.send(get.encode('ascii'))
        selector.register(key.fd, EVENT_READ, self.read_response)

    def read_response(self, key, mask):
        global stopped
        # 如果响应大于4KB，下一次循环会继续读
        chunk = self.sock.recv(4096)
        if chunk:
            self.response += chunk
        else:
            selector.unregister(key.fd)
            urls_todo.remove(self.url)
            if not urls_todo:
                stopped = True

if __name__ == '__main__':
    import time
    start = time.time()
    for url in urls_todo:
        crawler = Crawler(url)
        crawler.fetch()
    loop()
    print(time.time() - start)
```

1. 将任务逻辑代码拆解为若干个步骤，不同步骤以阻塞操作作为分界(即一遇到阻塞的操作，某步骤就结束，阻塞完成后需要进行的工作<u>放到它的下一个步骤(即回调函数)里</u>)  

2. <u>放到它的下一个步骤的具体操作就是将回调函数注册在select(poll/epoll/kqueue)模块上，由OS对阻塞事件进行等待和监听</u>  

3. select模块(内容太多，机制另文描述)仅仅是负责等待和监听，当监听的事件发生时它不会主动地调用回调函数执行下一步骤，所以需要一个<u>事件循环</u>不断地查询select模块，以获取监听到的事件，并从select模块中拿到事件的A.回调函数;B.对应状态数据

   ```python
   def loop():
       while not stopped:
           # 阻塞, 直到一个事件发生
           events = selector.select()
           for event_key, event_mask in events:
               callback = event_key.data
               callback(event_key, event_mask)
   ```

<font color=limegreen>从上文描述，select更像一个寄存器/堆栈＋监视器，注册时将一些变量/常量/状态数据/指针寄存在select模块里，然后开始监视，然后事件循环不停询问是否有监视对象满足了条件，如果有则从select中取出寄存的状态数据执行</font>  

优点：1.克服了竞态条件(保证数据独立隔离)<font color=Yellow>此处存疑，未能确定，因为不清楚多线程示例代码中的竞态条件是如何发生的，因此也就不能确定异步非阻塞是如何改进的，以下仅为推测：A.利用线程本身的资源共享范围(参考上文)将需要在回调函数中共享的数据封装在类的内部(利用self传递)，从而实现数据隔离；B.(此处可能不正确，select可能并不寄存状态数据)通过select寄存机制实现数据的隔离(谁寄存的包谁来取)</font>  

缺点：1.共享状态管理困难，同步阻塞版的`sock`对象从头使用到尾，而在回调的版本中，我们必须在`Crawler`实例化后的对象`self`里保存它自己的`sock`对象。如果不是采用OOP的编程风格，那需要把要共享的状态接力似的传递给每一个回调。多个异步调用之间，到底要共享哪些状态，事先就得考虑清楚，精心设计(<font color=Yellow>验证了优点1中的A</font>)；2.错误处理困难/栈撕裂，为了防止栈撕裂，异常必须以数据的形式返回，而不是直接抛出异常，然后每个回调中需要检查上次调用的返回值，以防错误吞没；3.破坏代码结构，回调层次过多导致阅读困难  

<font color=limegreen>对于缺点1，对于OOP不成为问题，正如示例代码实现的那样，成功利用线程的资源共享范围克服竞态条件，实现共享状态管理，至于POP是否是问题需要尝试实现一下；缺点1和缺点2其实是1个问题的一体两面，即异步回调的核心问题：使用原生的select回调机制会完全割裂共享的资源。如下图，有3个并发任务（1.A-->B-->C, 2.A'-->B'-->C', 3.A''-->B''-->C''），当遇到I/O阻塞时，步骤A向select注册回调函数(即步骤B)， A和B此时已经完全割裂开了，导致缺点1：必须精心设计步骤A和B之间共享的状态才能将数据在A和B之间传递，同时导致缺点2，B不知道它的前序步骤是A，所以如果不在回调检查上次调用的返回值的话，那么B报错的时候，就无法知道是并发任务1还是2还是3出错了，只知道B报错了。割裂的目的是为了克服竞态条件，但是这样的割裂程度太高，我们希望实现的割裂是A-->B-->C之间不割裂可以共享状态，相互通信知道前因后果，<u>就像ABC仍然在同一个函数内一样</u>，而在A和(A',B',C',A'',B'',C'')之间是完全割裂从而克服竞态条件，由此引入下面协程的改进方式</font>  

<div align="center"> <img src="https://blackholemedia.github.io/documents/statics/async.png" width="90%"> </div><br>

### 以协程（yield）模式的异步非阻塞方式改进  

既然使用原生的select机制的回调会导致共享的状态完全割裂，那么我们就利用协程改造一下回调的方式，让select依然能够为我所用。  

构造一个未来对象(Future)，未来对象的功能类似于寄存器，未来对象包含三个特点：  

1. 具备一个属性A，该属性用于保存上一阶段结果(即异步I/O的返回结果)；  
2. 具备一个属性B，该属性用于保存步进函数； 
3. 具备一个方法C(resume)，该方法用于设置上一阶段结果(属性A)，然后执行步进函数(属性B)； 

首先实现暂停(pause)功能，python中yield关键字天然具备暂停的功能，那么我们直接在任务逻辑代码中分界处(即异步阻塞I/O)增加yield关键字，该处即可实现暂停。<font color=limegreen>用异步非阻塞的方式模拟了同步阻塞，从任务逻辑代码的角度看，同步阻塞：任务执行着，然后遇到了I/O，然后停下来等待I/O返回，yield: 任务执行着，然后遇到了I/O，然后暂停，只是将I/O放到异步处理</font>，<font color=red>从而将代码结构转换为同步的结构</font>。任务逻辑代码基本与异步非阻塞方式的一致，拆解为若干个步骤，不同步骤之间按上述方式实现暂停。不同之处在于：阻塞时不是把下一步骤封装为回调函数，而是实例化一个未来对象，对该未来对象的方法C(resume)进行封装，封装后的函数作为回调函数  

暂停操作的具体细节为：1. 实例化一个未来对象，将未来要做的事情(保存异步结果、执行步进)都塞到未来对象里面；

实现恢复(resume)功能

再然后构造一个任务调度器，与其说是任务调度器，倒不如说是将任务逻辑代码改造成具备步进功能的代码，我愿称之为步进电机生成器，一段顺序执行的代码进来，变成了一段步进执行的代码出去。既然是改造任务逻辑代码，所以初始化时必然有一个入参是指明任务的，也就是我们的任务逻辑代码。

任务管理器必须耦合未来对象和任务逻辑代码

任务逻辑代码基本与异步非阻塞方式的一致，拆解为若干个步骤，不同步骤以阻塞操作作为分界，  

这个中间对象具有一个步进方法中间对象的作用类似于寄存器，如下图中的按钮：  

<div align="center"> <img src="https://blackholemedia.github.io/documents/statics/generator_async.png" width="90%"> </div><br>

### GIL锁  

GIL 是CPython 解释器（平常称为 Python）中的一个技术术语，中文译为全局解释器锁，其本质上类似操作系统的 Mutex。GIL 的功能是：在 CPython 解释器中执行的每一个 Python 线程，解释器都会先锁住自己仅供当前线程执行，以阻止别的线程执行。当然，CPython 不可能容忍一个线程一直独占解释器，它会轮流执行 Python 线程。这样一来，用户看到的就是“伪”并行，即 Python 线程在交替执行，来模拟真正并行的线程。既然 CPython 能控制线程伪并行，为什么还需要 GIL 呢？其实，这和 CPython 的底层内存管理有关。

```python
>>> import sys
>>> a = []
>>> b = a
>>> sys.getrefcount(a)
3
```

可以看到，a 的引用计数值为 3，因为有 a、b 和作为参数传递的 getrefcount 都引用了一个空列表。假设有两个 Python 线程同时引用 a，那么双方就都会尝试操作该数据，很有可能造成引用计数的条件竞争，导致引用计数只增加 1（实际应增加 2(<font color=Yellow>有点困惑，既然CPython可以轮流执行线程，那么前面说的'同时引用a'是什么意思？既然是轮流执行线程，甲线程引用的时候计数加一，轮到乙线程的时候再加一，这样计数不就加2了吗？</font>)），这造成的后果是，当第一个线程结束时，会把引用计数减少 1，此时可能已经达到释放内存的条件（引用计数为 0），当第 2 个线程再次视图访问 a 时，就无法找到有效的内存了  

### 基本异步编程  

> 回调＋事件循环  

基本模型：

### 在基本异步编程上的改进  

left blank  



## 编程实例设计  

### 问题  

client请求server，请求时server可能处于流量峰值，从而中断了client的请求，流量的峰值随机出现，假设client对于请求有时间限制t，在该时间内client必须拿到请求结果，无论是成功还是失败的结果，那么问题来了：如何提高成功的概率？  

### 设计思路  

提高成功概率的根本在于重试，直至成功。但是因为有时间限制t，所以如果顺序执行(失败后重试，重试失败后再重试，直至时间截止)，重试的次数会比较少，成功概率低。所以我们的方法就变成了：**同时干**，时间限制内同时建立多个连接发起多个请求，只要有一个连接成功了都意味着任务成功，哪怕其中有连接被server中断。  

分析具体需求：

1. 同时建立多个连接发起多个请求，可以选择多进程、多线程、多协程  
2. 发起请求后，主进程/线程/协程不需要等待请求的返回，所以采取非阻塞的方式  
3. 请求的返回应该主动告诉调用者(主进程/线程/协程)，所以采取异步的方式  

基于效率的考虑，优先采用多协程，这就意味着需要自己编写调度管理(即事件循环)

### 与顺序重试的测试对比  

left blank  



