
Table of Contents
=================

   * [编译](#编译)
      * [参考引用](#参考引用)
      * [编译的定义](#编译的定义)
      * [LINUX的一般编译过程概述](#linux的一般编译过程概述)
         * [预处理阶段](#预处理阶段)
         * [编译阶段](#编译阶段)
         * [汇编阶段](#汇编阶段)
         * [链接阶段](#链接阶段)
      * [编译汇编的实现历史](#编译汇编的实现历史)
         * [实现高级语言，不一定必须依靠更低级的语言](#实现高级语言不一定必须依靠更低级的语言)
         * [如何实现第一个高级语言的第一个编译器](#如何实现第一个高级语言的第一个编译器)
         * [汇编过程](#汇编过程)
      * [附录](#附录)
         * [图灵机与图灵完备](#图灵机与图灵完备)

Created by ALTA
# 编译  
<font color=#008000>绿色字体</font>代表个人的思考理解，<font color=Yellow>黄色字体</font>代表阅读理解过程中的疑问，<font color=Red>红色字体</font>代表关键重要信息，<u>下划线</u>代表次关键重要信息，`阴影`或 *一般斜体* 均表示引用或强调 

```python
# ---------------------------------- 输出结果
```

## 参考引用  

本文引用及参考自下列文章/网站， 版权归属原作者所有：

1. [编译入门：传说中的编译是在做什么](https://www.cnblogs.com/li--chao/p/9229927.html)
2. [程序语言都是怎么发明的](https://www.zhihu.com/question/358636057/answer/917465056)  
3. [图灵机与图灵完备](https://www.zhihu.com/question/20115374/answer/288346717)

## 编译的定义  

编译程序（Compiler）是一种程序。它把用高级语言写的源程序作为数据接收，经过翻译转换，产生面向机器的代码作为输出。
这当中代码还可能要由汇编程序或装配程序作进一步加工，得出目标程序，交给计算机执行

## LINUX的一般编译过程概述  

```c
#include <stdio.h>

int main()
{
    printf("happy new year!\n");
    return 0;
}
```

编译过程在Linux系统下一般分为4个抽象阶段

### 预处理阶段  

> .c --> .i  

此阶段主要完成#符号后面的各项内容到源文件的**替换**，例如头文件#include和宏定义#define, #ifdef等。可以用gcc的参数-E来指示编译器只做预处理而不进行下面的3个步骤。例如：

```shell
gcc –E hello.c -o hello.i 
```

### 编译阶段  

> .i --> .s

这个阶段编译器主要做词法分析、语法分析、语义分析等，在检查无错误后后，把代码**翻译成汇编语言**。 编译器将文本文件hello.i 翻译成文本文件hello.s, 它包含一个汇编语言程序，即一条低级机器语言指令。用gcc的参数-S来指示编译器只编译到汇编语言而不进行汇编和链接。 例如:

```shell
gcc -S hello.i -o hello.s
```

### 汇编阶段  

> .s --> .o

汇编器as 将hello.s**翻译成机器语言**，打包形成可重定位的目标文件hello.o 中（二进制文本形式）

```shell
gcc -c hello.s -o hello.o
```

### 链接阶段  

> .o --> binary

此阶段完成文件中调用的**各种函数跟静态库和动态库的连接**，并将它们一起打包**合并形成目标文件**，即可执行文件。本例中，printf函数存在于一个名为printf.o的单独预编译目标文件中。必须得将其并入到hello.o的程序中，链接器就是负责处理这两个的并入，结果得到hello文件，它就是一个可执行的目标文件。

```shell
gcc hello.o -o hello
```

其中，第1阶段和第2阶段由编译器完成，第3阶段由汇编器完成，第4阶段由链接器完成。

## 编译汇编的实现历史  

### 实现高级语言，不一定必须依靠更低级的语言  

由上文可知，编译主要将高级语言转换为汇编语言，汇编主要将汇编语言转换为二进制机器码。因此对于编译而言，**任何[图灵完备](#附录)的编程语言，理论上都是能用来写编译器的**，因此，可以采用某种高级语言实现另外一种高级语言的编译器

### 如何实现第一个高级语言的第一个编译器  

譬如 C++ 的编译器是 C++ 写的，那第一个 C++ 编译器要怎么编译自己呢(*先有鸡还是先有蛋*)？  

计算机科学里，这个问题对应于所谓的**自举** (Bootstrapping) 概念。一般来说，某种新语言 X 的第一个编译器 C1，需要用另一种语言来编写。接下来你就可以用 C1 编译出一个部分用 X 来写的新编译器 C2，而 C2 又可以编译出一个支持更多 X 特性的 C3，然后 C3 编译出 X 支持更好的 C4……不断重复迭代该过程。上述迭代可以简化为如下过程(**自举**)：  

1. 用汇编语言写一个C语言编译器  
2. 用C语言写一个C语言编译器的源码  
3. 用汇编版的编译器编译第2步的源码，即可得到一个编译器  
4. 汇编版的编译器可以丢掉了

更通俗的理解，是将编译器想像成一个加工零件的机床。这个机床既可以加工出普通零件，也可以加工出高级零件，最后组装出一台新的机床。第一台机床的零件都需要<font color=Red>手工打造</font>，造出的零件比较粗糙，但用第一台机床加工出的第二台机床，可能还有一些零件要靠手工，但机械化比例肯定比第一台机床高一些，加工效果也会更好一些。多重复几次这种【用粗糙机床制造更高精度机床】的过程后，**即便制造第一台机床的手工技术失传，我们仍然可以标准化地用机床来制造机床**  

历史上，最早的**C 编译器就是汇编实现**的。另外需要注意一下两点：

1. 自举在技术上其实也不是必须的。理论上你也可以一直用 C 甚至汇编来实现 C++ 编译器，可是这样你干嘛还要发明 C++ 呢？(即只执行上述自举过程的第1步)  
2. 只要你够牛逼，你还可以直接用自己设计的语言写出这门语言的编译器源码，然后**用你的脑子**把这份源码编译成该语言的第一个编译器。

那么问题来了，最初的最初，汇编过程是怎么实现的？难道是用二进制写一个编译器，将汇编语言转换为二进制代码？  

<font color=LimeGreen>不十分精确来说，编译和汇编实现的目标是一样的，将一种语言转换成另一种语言，原则上两者并无实质区别，而我们的最终目的都是转换成二进制序列(计算机上能够运行的只有二进制序列)，所以我们可以完全将编译和汇编合并为一个过程(即将高级语言/低级语言/汇编语言转换成二进制序列，上文中LINUX的'编译'其实就是指这个过程)，只是为了更准确的描述该过程中包含的细节，所以将该过程分为了编译和汇编两个过程。<u>这个过程本质上是一个映射过程(todo 关联现代编码模型)， 将字符(高低级语言/汇编语言)按照一定的规则转换成二进制序列(在下文中我们将这个过程称之为广义的编译过程)</u></font>  

<font color=LimeGreen>之所以造成先有鸡还是先有蛋的困惑是在于不同语境下指代的混淆。上文中编译器其实指代了两个对象：1.使用高级语言/低级语言/汇编语言写就的编译器源代码; 2.可实现编译功能的可执行二进制代码(序列).在“C++编译器是如何编译它自己呢？”这问题中，“编译器”指代的是1，所有编译过程的执行都是依靠2，所以这个问题的实质是2是如何在1之前诞生的，该问题其实等价于历史上第一个编译器(这里的编译器指的是可执行二进制代码，并且根据历史来看该二进制代码实现的是将汇编语言转换为二进制代码)是如何诞生的？而该问题又等价于在上古时代没有任何语言，只有0101的时候之怎么写程序的？引用一个例子：世界上一定存在一串二进制序列，其内容是我和Tayler Swift的性爱视频。这串二进制序列正常的诞生顺序是“我”和Tayler Swift先拍摄性爱视频，然后视频通过现代编码后形成了二进制序列存储在计算机中。假设有一块硬盘断电或者是雷劈了，恰巧形成了跟上述过程一样的二进制序列，那么不经过拍摄视频的过程也能创造出一个视频</font>

### 汇编过程  





## 附录  

### 图灵机与图灵完备   

1. 什么是图灵机  

      图灵机（Turing Machine）是图灵在1936年发表的 "On Computable Numbers, with an Application to the Entscheidungs problem"（《论可计算数及其在判定性问题上的应用》）中提出的*数学模型*，并非实体概念。

      图灵机包含以下几个结构：

      - 一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。
      - 一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。
      - 一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。
      - 一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。
      - 一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南。其实某种意义上，这个指令集就对应着程序员所写下的程序了。

      <div align="center"> <img src="https://blackholemedia.github.io/documents/statics/turing_machine.jpg" width="400px"> </div><br>

      运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“...011001...”）便作为输出，由人来解码为自然语言.

2. 可计算问题  

      图灵证明(<font color=yellow>todo 读一下论文看看证明过程</font>)了上述模型里所说的功能都能被以某种形式物理实现，那么任意可计算问题都可以被解决。这里所说的**可计算问题**，涉及到计算理论（Computation Theory）的概念。在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。

         >  A computational problem is a mathematical object representing a collection of questions that computers might be able to solve.

         计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）。它可以被理解为“是否存在一个算法，能解决在任何输入下的此计算问题”。不可计算的计算问题，比如著名的停机问题（Halting Problem）。它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？

         > given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever.

      简而言之，对于一个问题，对于任意输入，**只要人类可以保证算出结果**（不管花多少时间），那么图灵机就可以保证算出结果（不管花多少时间）。

3. 图灵完备  

      图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性.






