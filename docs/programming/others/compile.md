
Table of Contents
=================

   * [编译](#编译)
      * [阅读说明](#阅读说明)
      * [参考引用](#参考引用)
      * [编译的定义](#编译的定义)
      * [LINUX的一般编译过程概述](#linux的一般编译过程概述)
         * [预处理阶段](#预处理阶段)
         * [编译阶段](#编译阶段)
         * [汇编阶段](#汇编阶段)
         * [链接阶段](#链接阶段)
      * [编译汇编的实现历史](#编译汇编的实现历史)
         * [实现高级语言，不一定必须依靠更低级的语言](#实现高级语言不一定必须依靠更低级的语言)
         * [如何实现第一个高级语言的第一个编译器](#如何实现第一个高级语言的第一个编译器)
         * [汇编过程](#汇编过程)

Created by ALTA
# 编译  

<font color=#008000>绿色字体</font>代表个人的思考理解，<font color=Yellow>黄色字体</font>代表阅读理解过程中的疑问，<font color=Red>红色字体</font>代表关键重要信息，<u>下划线</u>代表次关键重要信息，`阴影`或 *一般斜体* 均表示引用或强调 

```python
# ---------------------------------- 输出结果
```

## 参考引用  

本文引用及参考自下列文章/网站， 版权归属原作者所有：

1. [编译入门：传说中的编译是在做什么](https://www.cnblogs.com/li--chao/p/9229927.html)
2. [程序语言都是怎么发明的](https://www.zhihu.com/question/358636057/answer/917465056)

## 编译的定义  

编译程序（Compiler）是一种程序。它把用高级语言写的源程序作为数据接收，经过翻译转换，产生面向机器的代码作为输出。
这当中代码还可能要由汇编程序或装配程序作进一步加工，得出目标程序，交给计算机执行

## LINUX的一般编译过程概述  

```c
#include <stdio.h>

int main()
{
    printf("happy new year!\n");
    return 0;
}
```

编译过程在Linux系统下一般分为4个抽象阶段

### 预处理阶段  

> .c --> .i  

此阶段主要完成#符号后面的各项内容到源文件的**替换**，例如头文件#include和宏定义#define, #ifdef等。可以用gcc的参数-E来指示编译器只做预处理而不进行下面的3个步骤。例如：

```shell
gcc –E hello.c -o hello.i 
```

### 编译阶段  

> .i --> .s

这个阶段编译器主要做词法分析、语法分析、语义分析等，在检查无错误后后，把代码**翻译成汇编语言**。 编译器将文本文件hello.i 翻译成文本文件hello.s, 它包含一个汇编语言程序，即一条低级机器语言指令。用gcc的参数-S来指示编译器只编译到汇编语言而不进行汇编和链接。 例如:

```shell
gcc -S hello.i -o hello.s
```

### 汇编阶段  

> .s --> .o

汇编器as 将hello.s**翻译成机器语言**，打包形成可重定位的目标文件hello.o 中（二进制文本形式）

```shell
gcc -c hello.s -o hello.o
```

### 链接阶段  

> .o --> binary

此阶段完成文件中调用的**各种函数跟静态库和动态库的连接**，并将它们一起打包**合并形成目标文件**，即可执行文件。本例中，printf函数存在于一个名为printf.o的单独预编译目标文件中。必须得将其并入到hello.o的程序中，链接器就是负责处理这两个的并入，结果得到hello文件，它就是一个可执行的目标文件。

```shell
gcc hello.o -o hello
```

其中，第1阶段和第2阶段由编译器完成，第3阶段由汇编器完成，第4阶段由链接器完成。

## 编译汇编的实现历史  

### 实现高级语言，不一定必须依靠更低级的语言  

由上文可知，编译主要将高级语言转换为汇编语言，汇编主要将汇编语言转换为二进制机器码。因此对于编译而言，**任何图灵完备(todo)的编程语言，理论上都是能用来写编译器的**，因此，可以采用某种高级语言实现另外一种高级语言的编译器

### 如何实现第一个高级语言的第一个编译器  

譬如 C++ 的编译器是 C++ 写的，那第一个 C++ 编译器要怎么编译自己呢？  

计算机科学里，这个问题对应于所谓的**自举** (Bootstrapping) 概念。一般来说，某种新语言 X 的第一个编译器 C1，需要用另一种语言来编写。接下来你就可以用 C1 编译出一个部分用 X 来写的新编译器 C2，而 C2 又可以编译出一个支持更多 X 特性的 C3，然后 C3 编译出 X 支持更好的 C4……不断重复迭代该过程。上述迭代可以简化为如下过程(**自举**)：  

1. 用汇编语言写一个C语言编译器  
2. 用C语言写一个C语言编译器的源码  
3. 用汇编版的编译器编译第2步的源码，即可得到一个编译器  
4. 汇编版的编译器可以丢掉了

更通俗的理解，是将编译器想像成一个加工零件的机床。这个机床既可以加工出普通零件，也可以加工出高级零件，最后组装出一台新的机床。第一台机床的零件都需要**<font color=Red>手工打造</font>**，造出的零件比较粗糙，但用第一台机床加工出的第二台机床，可能还有一些零件要靠手工，但机械化比例肯定比第一台机床高一些，加工效果也会更好一些。多重复几次这种【用粗糙机床制造更高精度机床】的过程后，**即便制造第一台机床的手工技术失传，我们仍然可以标准化地用机床来制造机床**  

历史上，最早的**C 编译器就是汇编实现**的。另外需要注意一下两点：

1. 自举在技术上其实也不是必须的。理论上你也可以一直用 C 甚至汇编来实现 C++ 编译器，可是这样你干嘛还要发明 C++ 呢？(即只执行上述自举过程的第1步)  
2. 只要你够牛逼，你还可以直接用自己设计的语言写出这门语言的编译器源码，然后**用你的脑子**把这份源码编译成该语言的第一个编译器。

那么问题来了，最初的最初，汇编过程是怎么实现的？难道是用二进制写一个编译器，将汇编语言转换为二进制代码？

### 汇编过程  

