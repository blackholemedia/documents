
Table of Contents
=================

   * [Tree](#tree)
      * [参考引用](#参考引用)
      * [定义](#定义)
      * [基本概念](#基本概念)
         * [节点名称](#节点名称)
         * [路径(path)](#路径path)
         * [内部路径长](#内部路径长)
         * [深度](#深度)
         * [高](#高)
         * [先序遍历](#先序遍历)
         * [后续遍历](#后续遍历)
         * [中序遍历](#中序遍历)
      * [各种树之间关系](#各种树之间关系)
         * [二叉树](#二叉树)
         * [完美二叉树](#完美二叉树)
         * [完全二叉树](#完全二叉树)
         * [完满二叉树](#完满二叉树)
         * [二叉查找树](#二叉查找树)
         * [AVL树](#avl树)
         * [伸展树](#伸展树)
         * [B-树](#b-树)

Created by ALTA
# Tree  
<font color=#008000>绿色字体</font>代表个人的思考理解，<font color=Yellow>黄色字体</font>代表阅读理解过程中的疑问，<font color=Red>红色字体</font>代表关键重要信息，<u>下划线</u>代表次关键重要信息，`阴影`或 *一般斜体* 均表示引用或强调 

```python
# ---------------------------------- 输出结果
```

## 参考引用  

本文引用及参考自下列文章/网站， 版权归属原作者所有：

1. 111111



## 定义  

树，即是以层次化方式组织和存放数据的特定数据结构

## 基本概念  

### 节点名称  

1. root: 根节点  
2. child: 子节点  
3. parent: 父节点  
4. sibling: 兄弟节点  
5. leaf: 树叶，没有子节点的节点  

### 路径(path)  

节点`n[1]`到`n[k]`之间的路径定义为节点`n[1], n[2],....n[k]`的一个序列，节点`n[i]`是`n[i + 1]`的父节点，路径长为该路径上的边数  

### 内部路径长  

一棵树**所有节点的深度和**称为内部路径长  

### 深度  

对于任意节点`n[i]`的深度为从root到`n[i]`的唯一路径长， 所以root的深度为0，一颗树的深度等于它的最深的树叶的深度。  

### 高  

对于任意节点`n[i]`的高为`n[i]`到一片树叶的最长路径的长， 所以所有树叶的高为0，一颗树的高等于它的根的高。树的深度等于树的高  

### 先序遍历  

对于节点的处理工作在它的诸儿子节点被处理之前完成的  

### 后续遍历  

对于节点的处理工作在它的诸儿子节点被处理之后完成的  

### 中序遍历  

先处理左儿子节点，然后处理节点本身，最后处理右儿子节点  

## 各种树之间关系  

二叉树

完美二叉树

完全二叉树  

完满二叉树

二叉查找树

带平衡条件的二叉查找树(AVL)

自平衡的二叉查找树(红黑树)

伸展树

B树

B+树

### 二叉树  

1. 定义  

   每个节点不能有多于2个儿子的树，儿子可以为空

### 完美二叉树  

树是满的，还是二叉的  

<div align="center"> <img src="https://blackholemedia.github.io/documents/statics/perfect_binary_tree.png" width="400px"> </div><br>

### 完全二叉树  

完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐  

<div align="center"> <img src="https://blackholemedia.github.io/documents/statics/complete_binary_tree.png" width="400px"> </div><br>

### 完满二叉树  

所有非叶子结点的度都是2。（只要你有孩子，你就必然是有两个孩子）  

<div align="center"> <img src="https://blackholemedia.github.io/documents/statics/full_binary_tree.png" width="400px"> </div><br>

### 二叉查找树  

1. 定义  

   在*二叉树*的基础上要求：左子树所有值小于节点，右子树所有值大于节点  
   
2. 基本操作  

   - Make_empty  

     初始化

   - find/find_max/find_min

     根据二叉树的特性，递归查找即可，时间复杂度为`O(log N)`

   - Insert  

     插入元素X，与find类似，沿树进行遍历， 如果找到X，则什么也不用做，否则将X插入遍历路径的最后一点上(<font color=green>因为插入的元素必然是树叶</font>)，所以时间复杂度也是`O(log N)`  

   - Delete  

     分作如下情形处理：

     A. 节点是树叶，直接删除就可以

     B. 如果节点有一个儿子，删除该节点并将其儿子指向被删除节点的父节点即可

     C. 如果节点有两个儿子，通常采取如下策略，使用节点右子树的最小节点代替待删除节点，然后删除右子树的最小节点(二次删除)， 因为右子树的最小节点要么是树叶(A)，要么只有一个儿子(B)

### AVL树  

带平衡条件的二叉查找树  

1. 定义  

   在*二叉查找树*的基础上要求：每个节点的左子树和右子树的高度最多差1，**空树的高度定义为-1**  

2. 单旋转  

   blank  

3. 双旋转  

   blank  

### 伸展树  

blank

### B-树  

非二叉树  

1. 定义  

   阶为M的B-树具备以下特性：  

   - <font color=yellow>树的根或者是一片树叶，或者其儿子数在2和M之间</font>  
   - 除根外，所有非树叶节点的儿子数在[M / 2]和M之间  
   - 所有的树叶都在相同的深度上  

   

